# playbooks/gitea-deploy.yml
---
# Ansible playbook to deploy or restore Gitea on my Synology NAS
# - Installs Container Manager (Docker)
# - Deploys MySQL and Gitea containers
# - Plans & gates destructive restore (fail on overlap)
# - Optionally restores from Backblaze B2 backup
# - Syncs SSL certificate
# - Restarts Gitea

- name: Deploy or Restore Gitea on Synology NAS
  hosts: nas
  become: true
  vars:
    dnsimple_oauth_token: "{{ lookup('ansible.builtin.env', 'DNSIMPLE_OAUTH_TOKEN') }}"
    dnsimple_endpoint: "{{ lookup('ansible.builtin.env', 'DNSIMPLE_ENDPOINT') | default('https://api.dnsimple.com', true) }}"
    certbot_email: "{{ lookup('ansible.builtin.env', 'CERTBOT_EMAIL') }}"
    certbot_command_args: [
      "certonly",
      "--dns-dnsimple",
      "-d", "{{ gitea_domain }}",
      "--email", "{{ certbot_email }}",
      "--agree-tos",
      "--no-eff-email",
      "--server", "https://acme-v02.api.letsencrypt.org/directory"
    ]
    # Domain and data paths
    gitea_domain: "nas.lan.jaxzin.com"
    gitea_port: "8443"
    gitea_data_path: "/volume1/docker/gitea"
    gitea_runner_data_path: "{{ gitea_data_path }}/gitea-runner"
    certbot_data_path: "/volume1/docker/certbot"
    # Gitea configuration paths
    gitea_app_ini_path_host: "{{ gitea_data_path }}/conf/app.ini"
    gitea_app_ini_path_container: "/etc/gitea/app.ini"
    # Docker images
    gitea_image_tag: "1.24.2-rootless"
    gitea_image: "gitea/gitea:{{ gitea_image_tag }}"
    gitea_db_image: "mysql:8"
    gitea_runner_image_tag: "0.2.12"
    gitea_runner_image: "gitea/act_runner:{{ gitea_runner_image_tag }}"
    # Database credentials (from environment)
    gitea_db_name: "gitea"
    gitea_db_user: "gitea"
    gitea_db_password: "{{ lookup('ansible.builtin.env','GITEA_DB_PASSWORD') }}"
    gitea_admin_username: "{{ lookup('ansible.builtin.env','GITEA_ADMIN_USERNAME') }}"
    gitea_admin_password: "{{ lookup('ansible.builtin.env','GITEA_ADMIN_PASSWORD') }}"
    gitea_admin_email: "{{ lookup('ansible.builtin.env','GITEA_ADMIN_EMAIL') }}"
    # Backblaze B2 backup settings
    b2_bucket: "{{ lookup('ansible.builtin.env','B2_ACCESS_KEY') }}"
    b2_access_key: "{{ lookup('ansible.builtin.env','B2_ACCESS_KEY') }}"
    b2_secret_key: "{{ lookup('ansible.builtin.env','B2_SECRET_KEY') }}"
    # SSL/TLS certificate management
    dsm_cert_name: nas-lan
    restore: "{{ lookup('ansible.builtin.env', 'GITEA_RESTORE') | bool }}"
  roles:
    - role: tafeen.synology.syno_pkg_install
      syno_pkg_name: "Container Manager"
      syno_pkg_state: present
      tags: docker
  tasks:
    - name: Validate required variables
      assert:
        that:
          - lookup('vars', item) is defined
          - lookup('vars', item) | string != ""
        fail_msg: "The required variable '{{ item }}' is undefined or is empty."
      loop:
        - b2_bucket
        - b2_access_key
        - b2_secret_key
        - certbot_email
        - dnsimple_endpoint
        - dnsimple_oauth_token
        - gitea_admin_username
        - gitea_admin_password
        - gitea_admin_email
        - gitea_db_password
        - restore

    - name: Install Python3
      include_role:
        name: tafeen.synology.syno_pkg_install
      vars:
        syno_pkg_name: "Python3"
        syno_pkg_state: present

    - name: Install pip
      command: python3 -m ensurepip --upgrade
      args:
        creates: /usr/bin/pip3

    - name: Create data directories for Gitea
      # Prepare persistent directories for both Gitea and MySQL
      file:
        path: "{{ gitea_data_path }}/{{ item }}"
        state: directory
        owner: root
        group: root
        mode: '0755'
      loop:
        - gitea
        - db
        - gitea-runner
      tags: directories

    - name: Create conf directory for Gitea
      file:
        path: "{{ gitea_data_path }}/conf"
        state: directory
        owner: root
        group: root
        mode: '0755'

    - name: Create Gitea Docker network
      community.docker.docker_network:
        name: gitea-net
        state: present

    - name: Create scripts directory
      file:
        path: "{{ certbot_data_path }}/scripts"
        state: directory
        owner: root
        group: root
        mode: '0755'

    - name: Create shared certs directory
      file:
        path: "{{ certbot_data_path }}/certs"
        state: directory
        owner: root
        group: root
        mode: '0755'

    - name: Create certbot conf directory
      file:
        path: "{{ certbot_data_path }}/conf"
        state: directory
        owner: root
        group: root
        mode: '0755'

    - name: Template dnsimple.ini for certbot
      template:
        src: dnsimple.ini.j2
        dest: "{{ certbot_data_path }}/certs/dnsimple.ini"
        owner: root
        group: root
        mode: '0600'

    - name: Create DNSimple environment file
      copy:
        content: |
          #!/bin/bash
          export DNSIMPLE_OAUTH_TOKEN="{{ dnsimple_oauth_token }}"
          export DNSIMPLE_ENDPOINT="{{ dnsimple_endpoint }}"
        dest: "{{ certbot_data_path }}/dnsimple_env.sh"
        owner: root
        group: root
        mode: '0600'

    - name: Template the renew-cert script
      template:
        src: renew-cert.sh.j2
        dest: "{{ certbot_data_path }}/scripts/renew-cert.sh"
        owner: root
        group: root
        mode: '0755'

    - name: Run initial certificate acquisition
      command: "{{ certbot_data_path }}/scripts/renew-cert.sh"
      args:
        creates: "{{ certbot_data_path }}/certs/live/{{ gitea_domain }}/fullchain.pem"
      environment:
        DNSIMPLE_OAUTH_TOKEN: "{{ dnsimple_oauth_token }}"
        DNSIMPLE_ENDPOINT: "{{ dnsimple_endpoint }}"

    - name: Schedule daily certificate renewal
      ansible.builtin.import_role:
        name: tafeen.synology.syno_crontab
      vars:
        minute: "0"
        hour: "3"
        user: "root"
        job: "{{ certbot_data_path }}/scripts/renew-cert.sh > /dev/null 2>&1"

    - name: Deploy MySQL container for Gitea
      # Launch a MySQL container for the Gitea database
      community.docker.docker_container:
        name: gitea-db
        image: "{{ gitea_db_image }}"
        state: started
        restart_policy: always
        networks:
          - name: gitea-net
        env:
          MYSQL_ROOT_PASSWORD: "{{ gitea_db_password }}"
          MYSQL_DATABASE: "{{ gitea_db_name }}"
          MYSQL_USER: "{{ gitea_db_user }}"
          MYSQL_PASSWORD: "{{ gitea_db_password }}"
        volumes:
          - "{{ gitea_data_path }}/db:/var/lib/mysql"
      tags: db

    - name: Configure Gitea app.ini
      template:
        src: app.ini.j2
        dest: "{{ gitea_app_ini_path_host }}"
        owner: "1000"
        group: "1000"
        mode: '0640'
      notify: Restart Gitea

    - name: Deploy Gitea container
      # Launch the Gitea application container
      community.docker.docker_container:
        name: gitea
        image: "{{ gitea_image }}"
        state: started
        restart_policy: always
        networks:
          - name: gitea-net
        env:
          USER_UID: "1000"
          USER_GID: "1000"
        ports:
          - "{{ gitea_port }}:3000"
          - "22222:22"
        volumes:
          - "{{ gitea_data_path }}/gitea:/data"
          - "{{ gitea_app_ini_path_host }}:{{ gitea_app_ini_path_container }}"
          - "{{ certbot_data_path }}/certs:/etc/letsencrypt:ro"
      tags: gitea
      notify: Restart Gitea

    - name: Wait for MySQL to be ready (from within Gitea container)
      community.docker.docker_container_exec:
        container: gitea
        command: nc -z gitea-db 3306
      register: db_check_result
      until: db_check_result.rc == 0
      retries: 15          # Try 15 times
      delay: 5             # Wait 5 seconds between retries (total wait time: 75s)
      changed_when: false  # This task just checks status, it doesn't make a change

    - name: Check if Gitea admin user exists
      community.docker.docker_container_exec:
        container: gitea
        command: >
          /bin/sh -c "
          /app/gitea/gitea admin user list
          --config {{ gitea_app_ini_path_container }} | grep -q '\b{{ gitea_admin_username }}\b'
          "
      register: admin_check
      failed_when: admin_check.rc not in [0, 1] # Only fail on unexpected return codes
      changed_when: false # This task is just a check, not a change

    - debug:
        msg: "Admin user '{{ gitea_admin_username }}' already exists: {{ admin_check.rc == 0 }}"
        verbosity: 1

    - name: Create Gitea admin user inside the container
      community.docker.docker_container_exec:
        container: gitea
        command: >
          /app/gitea/gitea admin user create
          --config {{ gitea_app_ini_path_container }}
          --username '{{ gitea_admin_username }}'
          --password '{{ gitea_admin_password }}'
          --email '{{ gitea_admin_email }}'
          --admin
      when: admin_check.rc != 0
      register: admin_create
      changed_when: admin_create.rc == 0

    - name: Check if Gitea API token is already persisted
      stat:
        path: "{{ gitea_data_path }}/conf/api_token.txt"
      register: api_token_file

    - name: Load Gitea API token from remote file if it exists
      block:
        - name: Read Gitea API token from remote file
          command: "cat {{ gitea_data_path }}/conf/api_token.txt"
          register: api_token_content
          changed_when: false

        - name: Set Gitea API token fact
          set_fact:
            gitea_api_token: "{{ api_token_content.stdout | trim }}"
      when: api_token_file.stat.exists

    - name: Generate and persist Gitea API token if it does not exist
      when: not api_token_file.stat.exists
      block:
        - name: Create Gitea API token via API
          ansible.builtin.uri:
            url: "https://{{ gitea_domain }}:{{ gitea_port }}/api/v1/users/{{ gitea_admin_username }}/tokens"
            method: POST
            user: "{{ gitea_admin_username }}"
            password: "{{ gitea_admin_password }}"
            force_basic_auth: yes
            validate_certs: no
            body_format: json
            body:
              name: "ansible-bootstrap-token"
              scopes: ["read:admin", "write:admin"]
            status_code:
              - 200
              - 201
          register: new_token_result

        - name: Set API token fact from new token
          set_fact:
            gitea_api_token: "{{ new_token_result.json.sha1 }}"

        - name: Persist the new API token to the filesystem
          copy:
            content: "{{ gitea_api_token }}"
            dest: "{{ gitea_data_path }}/conf/api_token.txt"
            owner: "{{ ansible_user | default(lookup('env', 'USER')) }}"
            group: "{{ ansible_user | default(lookup('env', 'USER')) }}"
            mode: '0600'

    - name: Check if Gitea runner token is already persisted
      stat:
        path: "{{ gitea_data_path }}/conf/runner_token.txt"
      register: runner_token_file

    - name: Load Gitea runner token from remote file if it exists
      block:
        - name: Read Gitea runner token from remote file
          command: "cat {{ gitea_data_path }}/conf/runner_token.txt"
          register: runner_token_content
          changed_when: false
        - name: Set Gitea runner token fact
          set_fact:
            gitea_runner_token: "{{ runner_token_content.stdout | trim }}"
      when: runner_token_file.stat.exists

    - name: Generate and persist Gitea runner token if it does not exist
      when: not runner_token_file.stat.exists
      block:
        - name: Get Gitea runner registration token
          uri:
            url: "https://{{ gitea_domain }}:{{ gitea_port }}/api/v1/admin/runners/registration-token"
            method: GET
            headers:
              Authorization: "token {{ gitea_api_token }}"
            validate_certs: no
          register: new_runner_token_result

        - name: Set runner token fact from new token
          set_fact:
            gitea_runner_token: "{{ new_runner_token_result.json.token }}"

        - name: Persist the new runner token to the filesystem
          copy:
            content: "{{ gitea_runner_token }}"
            dest: "{{ gitea_data_path }}/conf/runner_token.txt"
            owner: "{{ ansible_user | default(lookup('env', 'USER')) }}"
            group: "users"
            mode: '0600'

    - name: Deploy Gitea runner container
      community.docker.docker_container:
        name: gitea-runner
        image: "{{ gitea_runner_image }}"
        state: started
        restart_policy: always
        networks:
          - name: gitea-net
        dns_opts:
          - "ndots:0"
        env:
          GITEA_INSTANCE_URL: "https://{{ gitea_domain }}:{{ gitea_port }}"
          GITEA_RUNNER_REGISTRATION_TOKEN: "{{ gitea_runner_token }}"
          GITEA_RUNNER_NAME: "nas-runner"
          GITEA_RUNNER_LABELS: "docker,linux,amd64"
        volumes:
          - "{{ gitea_runner_data_path }}:/data"
          - "/var/run/docker.sock:/var/run/docker.sock"

    - block:
        - name: Ensure B2 CLI is installed (plan-restore)
          pip:
            name: b2
            state: present

        - name: Download backup tarball for planning
          command: >
            b2 download-file-by-name
            "{{ b2_bucket }}"
            "latest-gitea-backup.tar.gz"
            "/tmp/gitea-backup.tar.gz"
          environment:
            B2_APPLICATION_KEY_ID: "{{ b2_access_key }}"
            B2_APPLICATION_KEY: "{{ b2_secret_key }}"
          args:
            creates: "/tmp/gitea-backup.tar.gz"

        - name: Detect overlaps
          shell: |
            tar -tf /tmp/gitea-backup.tar.gz | while read f; do
              if [ -e "{{ gitea_data_path }}/$f" ]; then
                echo "$f"
              fi
            done
          args:
            executable: /bin/bash
          register: overlaps
          changed_when: false

        - name: Abort on overlaps
          fail:
            msg: |
              Destructive restore would overwrite these files:
              {{ overlaps.stdout_lines | join('\n  - ') }}
      when: restore | default(false) | bool
      tags: plan-restore

    - name: Restore latest backup from Backblaze
      when:
        - restore | default(false) | bool
        - not ansible_check_mode
      block:
        - name: Ensure B2 CLI is installed (restore)
          pip:
            name: b2
            state: present

        - name: Download backup archive
          command: >
            b2 download-file-by-name
            "{{ b2_bucket }}"
            "latest-gitea-backup.tar.gz"
            "/tmp/gitea-backup.tar.gz"
          environment:
            B2_APPLICATION_KEY_ID: "{{ b2_access_key }}"
            B2_APPLICATION_KEY: "{{ b2_secret_key }}"
          args:
            creates: "/tmp/gitea-backup.tar.gz"

        - name: Extract backup
          unarchive:
            src: "/tmp/gitea-backup.tar.gz"
            dest: "{{ gitea_data_path }}"
            remote_src: yes
          notify: Restart Gitea
      tags: restore

  handlers:
    - name: Restart Gitea
      community.docker.docker_container:
        name: gitea
        state: started
        restart: yes